---
layout: post
title:  "js 引用类型的赋值"
date:   2016-08-02
author: "magma"
keywords: js 数据类型
tags: js
---

> 基本数据类型存放在栈上，引用类型存放于堆上。在js中这种差别最直观的显现在赋值和比较上。

### 赋值
赋值的问题很迷人，想当年我高一的时候参加编程兴趣班，老师说等号是用来赋值的，我愤而走人（现在十分后悔），老子各种等式方程解的出神入化，只知道等号就是两边相等。然后到了大学，第一堂计算机课老师说起等号的赋值行为一大群人懵逼，我心中又充满自豪，“老子高一的时候就知道等号在编程语言里的赋值意义！”

后来的很多次我都以为自己最终真正掌握了赋值的真谛...

前一次我写的文章在[这里](http://blog.csdn.net/longjuesi/article/details/39694497)，以我现在的眼光来看并没有错，但是并没有提到我本人的盲点，每个人的盲点都不一样。

在学校的时候我已经理解了堆栈的区别，指针变量与其他变量的区别，什么传值、传引用、传地址张口就能扯，对数据存储传递（赋值）行为了解的十分深入。然后我在两年前接触到js时，基本没学，就是稍微看了下变量、基本语法，大概两三个小时就开始写web前端了——直接迁移了c语言的概念。

但是这样带来了隐患：

#### 例子A
```javascript
var a = [1,2,3];
function foo(arr){
	var _arr = arr;
	_arr.push(2);
}
foo(a);
console.log(a)
//问：打印出的结果是什么

```
形参相当于一种占位符，在函数实现调用的时候被实参传值，js中没有传引用和地址，只有传值。但是传值也是耐人寻味的。在上面的中，输出的a其实是**[1,2,3,2]**。

如果是c语言它应当还是**[1,2,3]**。

就像我上面贴的文章里描述的，引用类型存放于堆上，**var a = [1,2,3];** 这句赋值的过程是这样的：

1. 在当前运行的环境栈上声名一个空间，索引名为a
2. 新建一个对象[1,2,3]，存放于堆上空白地址xxxx中
3. 将xxxx这个地址数赋值给a

当**foo(a)**执行时，传给arr的并不是[1,2,3]这个对象，而是xxxx这个地址号。在需要使用arr的时候，js解释器才会根据这个地址号去找到[1,2,3]。

你看，虽然美其名曰只有传值，但是人家引用类型变量的值实际就是地址。

以上的结论虽然我很早就理解了，但是下面这种情况一度让我懵逼：

#### 例子B

```javascript
var a = {name:"mike"};
var b = a;
b = {name:"jobs"};
console.log(a);
//问：打印出a的值是什么
```
我之前虽然知道a的值是什么，但是用我上面那套理解推断不出这个结果，我的推断是这样的（错误的推断）:

只解释第三行 **=>**  找到b中存放的地址所对应的堆上的具体的对象 {name:"mike"}，用 {name:"jobs"} 替换这原先的值，所以a的值就是{name:"jobs"}

我的推断是不是很完美？

然而事实是下面的推断也很完美，并且js解释器就是这么做的：

b = {name:"jobs"} **=>**  新建一个对象 {name:"jobs"} 存放于堆上地址为xyz的地方，将xyz赋值给b。所以a中依然存放着指向 {name:"mike"} 的地址，值并没有因为b的重新赋值而有所改变。

#### 总结
如果我用汇编，非常容易就能发现内部实现的细节：**js中，引用对象在赋值时，都是地址在玩，跟原对象屁关系都没有。**

### 比较
还是上面那句话，稍微变下：**js中，引用对象在比较时，都是地址在玩，跟原对象屁关系都没有。**

当年我才毕业用c#时，翔实被这坑了下。当年基本就钻研透了，至今并没有发现理解有偏差的地方。



希望这是我最后一次理解了赋值的真谛，以后不要再发现什么新的盲点了。
